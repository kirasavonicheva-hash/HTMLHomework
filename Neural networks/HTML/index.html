<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Визуализация нейронных сетей</title>
  <style>
    :root{--bg:#0a0a1a;--node1:#ff0055;--node2:#00ffaa;--node3:#aa00ff}
    html,body{height:100%;margin:0;font-family:monospace;background:var(--bg);overflow:hidden;color:#fff}
    .app{position:absolute;inset:0;display:flex;flex-direction:column;padding:20px}
    header{text-align:center;margin-bottom:30px}
    h1{font-size:clamp(24px,5vw,48px);margin:0;background:linear-gradient(90deg,var(--node1),var(--node2),var(--node3));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
    .controls{display:flex;gap:10px;justify-content:center;margin-bottom:20px}
    .btn{background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.3);color:white;padding:8px 16px;border-radius:4px;cursor:pointer;transition:all 0.2s}
    .btn:hover{background:rgba(255,255,255,0.2);transform:translateY(-2px)}
    .slider-container{color:#88ff88;margin:0 15px}
    #neuralCanvas{flex:1;border:1px solid rgba(255,255,255,0.2);border-radius:8px;background:rgba(0,0,0,0.3)}
    .node{position:absolute;border-radius:50%;pointer-events:none;mix-blend-mode:screen}
    .pulse{animation:pulse 2s infinite}
    @keyframes pulse{0%,100%{box-shadow:0 0 0 0 rgba(255,0,85,0.7)}50%{box-shadow:0 0 0 20px rgba(255,0,85,0)}}
    .info{position:absolute;bottom:10px;left:10px;font-size:11px;color:#888}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>НЕЙРОННЫЕ СЕТИ В ДВИЖЕНИИ</h1>
      <div class="controls">
        <button class="btn" id="addLayer">Добавить слой</button>
        <button class="btn" id="addNode">Добавить нейрон</button>
        <button class="btn" id="train">Обучить сеть</button>
        <button class="btn" id="fire">Активировать</button>
        <div class="slider-container">
          Скорость: <input type="range" id="speed" min="1" max="10" value="5">
        </div>
      </div>
    </header>
    <canvas id="neuralCanvas"></canvas>
  </div>
  <div class="info">Каждый нейрон — уникальная единица информации • Связи формируются динамически</div>

  <script>
    const canvas = document.getElementById('neuralCanvas');
    const ctx = canvas.getContext('2d');
    
    let width = canvas.width = canvas.offsetWidth;
    let height = canvas.height = canvas.offsetHeight;
    
    const nodes = [];
    const connections = [];
    const layers = 3;
    const nodesPerLayer = 4;
    let animationSpeed = 5;
    
  
    function initNetwork(){
      nodes.length = 0;
      connections.length = 0;
      
      for(let l=0; l<layers; l++){
        const layerNodes = [];
        for(let n=0; n<nodesPerLayer; n++){
          const x = (l+1) * (width/(layers+1));
          const y = (n+1) * (height/(nodesPerLayer+1)) + Math.random()*30 - 15;
          const node = {
            x, y,
            vx: 0, vy: 0,
            radius: 15 + Math.random()*10,
            color: l===0 ? '#ff0055' : l===layers-1 ? '#00ffaa' : '#aa00ff',
            layer: l,
            activation: 0,
            pulse: 0
          };
          nodes.push(node);
          layerNodes.push(node);
        }
        
        
        if(l > 0){
          const prevLayer = nodes.filter(n => n.layer === l-1);
          layerNodes.forEach(node => {
            prevLayer.forEach(prevNode => {
              if(Math.random() > 0.3){
                connections.push({
                  from: prevNode,
                  to: node,
                  weight: Math.random()*2 - 1,
                  active: false
                });
              }
            });
          });
        }
      }
    }
    
    function drawNetwork(){
      ctx.clearRect(0,0,width,height);
      
     
      ctx.strokeStyle = 'rgba(255,255,255,0.05)';
      ctx.lineWidth = 1;
      const gridSize = 40;
      for(let x=0; x<width; x+=gridSize){
        ctx.beginPath();
        ctx.moveTo(x,0);
        ctx.lineTo(x,height);
        ctx.stroke();
      }
      for(let y=0; y<height; y+=gridSize){
        ctx.beginPath();
        ctx.moveTo(0,y);
        ctx.lineTo(width,y);
        ctx.stroke();
      }
      
   
      connections.forEach(conn => {
        const gradient = ctx.createLinearGradient(
          conn.from.x, conn.from.y,
          conn.to.x, conn.to.y
        );
        
        if(conn.active){
          gradient.addColorStop(0, '#ffff00');
          gradient.addColorStop(1, '#ff00ff');
          ctx.lineWidth = 3;
        } else {
          gradient.addColorStop(0, `rgba(255,255,255,${0.1 + Math.abs(conn.weight)*0.1})`);
          gradient.addColorStop(1, `rgba(255,255,255,${0.05 + Math.abs(conn.weight)*0.05})`);
          ctx.lineWidth = Math.abs(conn.weight) * 2;
        }
        
        ctx.strokeStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(conn.from.x, conn.from.y);
        ctx.lineTo(conn.to.x, conn.to.y);
        ctx.stroke();
        
        if(conn.active){
          const progress = conn.signalProgress || 0;
          const x = conn.from.x + (conn.to.x - conn.from.x) * progress;
          const y = conn.from.y + (conn.to.y - conn.from.y) * progress;
          
          ctx.fillStyle = '#ffff00';
          ctx.beginPath();
          ctx.arc(x, y, 4, 0, Math.PI*2);
          ctx.fill();
          
          conn.signalProgress += 0.05 * animationSpeed;
          if(conn.signalProgress >= 1){
            conn.active = false;
            conn.signalProgress = 0;
          }
        }
      });
      
      
      nodes.forEach(node => {
        
        const gradient = ctx.createRadialGradient(
          node.x, node.y, 0,
          node.x, node.y, node.radius*2
        );
        gradient.addColorStop(0, node.color);
        gradient.addColorStop(1, 'transparent');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(node.x, node.y, node.radius*2, 0, Math.PI*2);
        ctx.fill();
        
        
        ctx.fillStyle = node.color;
        ctx.beginPath();
        ctx.arc(node.x, node.y, node.radius, 0, Math.PI*2);
        ctx.fill();
        
        if(node.pulse > 0){
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(node.x, node.y, node.radius + node.pulse*10, 0, Math.PI*2);
          ctx.stroke();
          node.pulse -= 0.1 * animationSpeed;
        }
        
        ctx.fillStyle = 'white';
        ctx.font = '12px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(node.activation.toFixed(1), node.x, node.y + 4);
        
     
        node.x += node.vx;
        node.y += node.vy;
        
       
        if(node.x < node.radius) node.vx = Math.abs(node.vx);
        if(node.x > width - node.radius) node.vx = -Math.abs(node.vx);
        if(node.y < node.radius) node.vy = Math.abs(node.vy);
        if(node.y > height - node.radius) node.vy = -Math.abs(node.vy);
        
        
        node.vx *= 0.95;
        node.vy *= 0.95;
      });
    }
    
    function activateRandom(){
      const inputNodes = nodes.filter(n => n.layer === 0);
      if(inputNodes.length === 0) return;
      
      const randomNode = inputNodes[Math.floor(Math.random()*inputNodes.length)];
      randomNode.activation = 1;
      randomNode.pulse = 1;
      
      connections
        .filter(conn => conn.from === randomNode)
        .forEach(conn => {
          conn.active = true;
          conn.signalProgress = 0;
          
          setTimeout(() => {
            conn.to.activation = Math.min(1, conn.to.activation + conn.weight);
            conn.to.pulse = 0.5;
            
           
            if(conn.to.layer < layers-1){
              connections
                .filter(c => c.from === conn.to)
                .forEach(nextConn => {
                  nextConn.active = true;
                  nextConn.signalProgress = 0;
                });
            }
          }, 300);
        });
    }
    
    function trainNetwork(){
      
      connections.forEach(conn => {
        conn.weight += (Math.random()*0.4 - 0.2);
        conn.weight = Math.max(-1, Math.min(1, conn.weight));
      });
      
      
      nodes.forEach(node => {
        node.vx += (Math.random()-0.5)*2;
        node.vy += (Math.random()-0.5)*2;
      });
    }
    
    function animate(){
      drawNetwork();
      requestAnimationFrame(animate);
    }
    
    
    document.getElementById('addLayer').addEventListener('click', () => {
      
      const newLayerIndex = Math.floor(Math.random()*(layers-1)) + 1;
      nodes.forEach(node => {
        if(node.layer >= newLayerIndex){
          node.layer++;
        }
      });
      initNetwork();
    });
    
    document.getElementById('addNode').addEventListener('click', () => {
      
      const layer = Math.floor(Math.random()*layers);
      const x = (layer+1) * (width/(layers+1));
      const y = Math.random()*height;
      
      nodes.push({
        x, y,
        vx: 0, vy: 0,
        radius: 12 + Math.random()*8,
        color: layer===0 ? '#ff0055' : layer===layers-1 ? '#00ffaa' : '#aa00ff',
        layer: layer,
        activation: 0,
        pulse: 0
      });
    });
    
    document.getElementById('train').addEventListener('click', trainNetwork);
    
    document.getElementById('fire').addEventListener('click', activateRandom);
    
    document.getElementById('speed').addEventListener('input', (e) => {
      animationSpeed = parseInt(e.target.value);
    });
    
    
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      let closest = null;
      let minDist = Infinity;
      
      nodes.forEach(node => {
        const dist = Math.sqrt((node.x - x)**2 + (node.y - y)**2);
        if(dist < node.radius && dist < minDist){
          minDist = dist;
          closest = node;
        }
      });
      
      if(closest){
        closest.activation = 1;
        closest.pulse = 1;
        activateRandom();
      } else {
       
        const layer = Math.floor((x / width) * layers);
        nodes.push({
          x, y,
          vx: 0, vy: 0,
          radius: 15,
          color: layer===0 ? '#ff0055' : layer===layers-1 ? '#00ffaa' : '#aa00ff',
          layer: layer,
          activation: 0.5,
          pulse: 0.5
        });
      }
    });
    
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
     
      nodes.forEach(node => {
        const dx = node.x - x;
        const dy = node.y - y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        if(dist < 100){
          node.vx += (dx/dist) * (100-dist) * 0.01;
          node.vy += (dy/dist) * (100-dist) * 0.01;
        }
      });
    });
    
 
    initNetwork();
    animate();
    
    
    setInterval(() => {
      if(Math.random() < 0.3) activateRandom();
    }, 1000);
    
   
    window.addEventListener('resize', () => {
      width = canvas.width = canvas.offsetWidth;
      height = canvas.height = canvas.offsetHeight;
      initNetwork();
    });
  </script>
</body>

</html>
